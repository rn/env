# -*- mode: sh -*-

##
## recursive grep through selected source files
##
function sgrep() {
    find . \( \
         -name "*.[ch]" \
         -or -name "*.cc" -or -name "*.cpp" -or -name "*.hh" \
         -or -name "*.cs" \
         -or -name "*.el" \
         -or -name "*.ml" -or -name "*.mli" \
         -or -name "*.ps1" -or -name "*.psm1"\
         -or -name "*.py" \
         -or -name "*.go" \
         -or -name "*.[sS]" \
         -or -name "*.sh" \
         -or -name "*.swift" \
         -or -name "*.uc" \
         \
         -or -name "Make*" -or -name "*.mk" \
         -or -name "Dockerfile*" \
         \
         -or -name "README*" \
         -or -name "*.tex" -or -name "*.bib" \
         -or -name "*.md" \
         -or -name "*.xml" \
         -or -name "*.html" \
         \
         -or -name "*.json" \
         -or -name "*.yml" \
         -or -name "*.yaml" \
         \
         \) -and \( \
         \-not -path "*vendor*" \
         \) \
         -print0 | xargs -0 grep -Ensi --colour "$@"
}

##
## recursive grep through all files (except git files)
##
function trawl() {
    find . -type f -and \( \! -path "*.git*" \) \
         -print0 | xargs -0 grep -Ensi --colour "$@"
}


##
## Update brew
##
function brew-up() {
    brew update && brew upgrade && brew cleanup
    brew cask update && brew cask cleanup
}

##
## Docker functions
##

# remove all stopped containers
function docker-rmas() {
    docker rm $(docker ps -aq)
}
function docker-rmasf() {
    docker rm -f $(docker ps -aq)
}

# remove dangling images
function docker-rmid() {
    docker rmi $(docker ps --all --quiet)
}

# List all tags for a image
# http://stackoverflow.com/questions/28320134/how-to-list-all-tags-for-a-docker-image-on-a-remote-registry
function docker-tags() {
    image="$1"
    tags=`wget -q https://registry.hub.docker.com/v1/repositories/${image}/tags -O -  | sed -e 's/[][]//g' -e 's/"//g' -e 's/ //g' | tr '}' '\n'  | awk -F: '{print $3}'`

    if [ -n "$2" ]
    then
        tags=` echo "${tags}" | grep "$2" `
    fi

    echo "${tags}"
}

##
## Misc functions
##

# download crash report
function pinata-logs() {
    cd ~/src/docker/pinata/support/s3
    mkdir -p ~/tmp/logs
    docker build -t pinata:fetch -f Dockerfile.fetch .
    docker run -it --rm \
           -v ~/tmp/logs:/logs  \
           -v ~/.aws/credentials:/root/.aws/credentials \
           pinata:fetch $1 $2 $3
    cd ~/tmp/logs/$2/$3
    unzip *.zip
    tar xf *.tar
}

##
## Functions do deal with repositories
##

# Set docker username/email on a local repository
function repo-docker() {
    git config --local user.name "Rolf Neugebauer"
    git config --local user.email "rolf.neugebauer@docker.com"
}

# Update gtags if use on a repository
# must be executed in the root of the repository
function _repo_gtags_up() {
    [ -f GTAGS ] && global -u
}


# Update a git repository
# $1: Path to *toplevel* of repository.
# - Assumes that master branch is clean
# - Stash any local changes on current branch
# - If it is a github fork
#   + pull from upstream
#   + pull from master
#   + merge upstream onto master (should be fast-forward)
#   + push master to github fork
function _repo_git_up() {
    pushd $1 > /dev/null
    branch=`git rev-parse --abbrev-ref HEAD`
    changes=`git diff-index --name-only HEAD --`
    upstream=`git remote -v | grep upstream`

    # Stash changes and switch to master
    [ -n "$changes" ] && git stash
    [ ! "$branch" = "master" ] && git checkout master

    # pull or fetch/merge
    if [ -n "$upstream" ]; then
        git fetch upstream
        git merge upstream/master
        git fetch
        git push --tags --prune origin master
    else
        git pull
    fi

    # switch back to branch and apply stash
    [ ! "$branch" = "master" ] && git checkout $branch
    [ -n "$changes" ] && git stash apply && git stash clear

    # update tags
    _repo_gtags_up

    popd > /dev/null
}

# Update a Mercurial/hg repository
# $1: Path to repository
function _repo_hg_up() {
    pushd $1 > /dev/null

    # XXX This could be more sophisticated
    hg pull -u

    # update tags
    _repo_gtags_up

    popd > /dev/null
}

# Update a repository
# $1: Optional argument for the path (otherwise $PWD)
function repo-up () {
    [ -z "$1" ] && r=`pwd` || r=$1

    # Work out if this is a git or hg repository
    git_dir=`git -C $r rev-parse --show-toplevel 2> /dev/null`
    hg_dir=`hg --cwd $r root 2> /dev/null`
    if [ -n "$git_dir" ]; then
        _repo_git_up $git_dir
    elif [ -n "$hg_dir" ]; then
        _repo_hg_up $hg_dir
    fi
}


##
## I keep a bunch of read-only repositories under ~/src/repos and
## others elsewhere.  These functions help me to keep them in sync
## with upstream.
##

# List repositories (and their source).
# If any argument is supplied print out commands to reproduce the setup
function repos-ls () {
    git_repos=`find ~/src/repos/ -type d -name .git`
    hg_repos=`find ~/src/repos/ -type d -name .hg`

    echo "### Git repositories"
    for r in $git_repos; do
        p=`dirname $r`
        b=${p#$HOME/src/repos//}
        s=`git -C $p remote -v | grep fetch | awk '{print $2}'`
        if [ -z "$1" ]; then
            printf "%-25s %s\n" $b $s
        else
            d=`dirname $b`
            echo "(mkdir -p $d; cd $d; git clone $s)"
        fi
    done

    echo "### HG repositories"
    for r in $hg_repos; do
        p=`dirname $r`
        b=${p#$HOME/src/repos//}
        s=`hg -R $p paths default`
        if [ -z "$1" ]; then
            printf "%-25s %s\n" $b $s
        else
            d=`dirname $b`
            echo "(mkdir -p $d; cd $d; hg clone $s)"
        fi
    done
}

# Update all repositories (optionally in a given directory only)
function repos-up () {
    dir=~/src/repos/
    [ "$1" ] && dir=$1
    git_repos=`find ${dir} -type d -name .git`
    hg_repos=`find ${dir} -type d -name .hg`

    for r in $git_repos; do
        p=`dirname $r`
        echo
        echo "=== Pulling $p"
        _repo_git_up $p
    done

    for r in $hg_repos; do
        p=`dirname $r`
        echo
        echo "=== Pulling $p"
        _repo_hg_up $p
    done
}
